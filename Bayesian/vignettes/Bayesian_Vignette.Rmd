---
title: "Bayesian_Vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Bayesian_Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
This first function "SamplingFunction" takes a data frame of binary data points. In this
case, the supplementary data "SampleData.csv" is included. SampleData contains the results of 100 trials
where in each trial a coin was flipped 10 times. When this Data frame is inputted into the function along with the number of trials (number of columns), the function will sum all each column and create a density plot of those sums (frequencies)


```{r setup,}
library(Bayesian)

SamplingFunction<-function(SampleData, NumbTrials){
  
  for (i in 1:NumbTrials){
    FrequencyVector[i]<- sum(SampleData[1:nrow(SampleData), i])
  }
  #making plot
  plot(density(FrequencyVector), col = "Blue")
  return(FrequencyVector)
}

```
 A sample of the inputs for the SamplingFunction will be included below.
```{r, eval = FALSE}
library(Bayesian)

SampleData <-read.csv("SampleData.csv")

NumbTrials <- ncol(SampleData)
FrequencyVector <- vector(mode= "numeric", length = NumbTrials)       
```
The second function, Prior_Function, plots a normal curve from from an input of a vector. That is,
a vector is fed into the function, and the function makes a red plot in base R of the normal curve
that fits the given data. Within the function, there is ability to change the mean and the
standard deviation of the data to change the shape of the distribution.
```{r}
library(Bayesian)

Prior_Function<-function(prior_data){
  prior <- dnorm(prior_data, mean = 5.05, sd = 1)
  plot(prior_data, prior, type = "l", col = "red")
}

```
Below will be an example input for function 2, Prior_Function. Here, a sample data vector of numbers from 
0.1 to 10 with increments of 0.1 were created and stored in "prior_data." A vector of length equal to the number of trials (length 100) was pre-filled with 0's for optimal space allocation.

```{r, eval = FALSE}
library(Bayesian)
prior_data <- seq(from = 0.1, to = 10, by = .1)
prior <- vector(mode= "numeric", length = NumbTrials)
```
The third function, Posterior_Function, takes 4 inputs. Two of the inputs are vectors from the previous two functions. The first is "FrequencyVector" which is the vector of sums of each column of the SampleData data frame. The other vector is the "prior" vector which contains the values generated by dnorm(prior_data). The other two inputs to this function are numerics. They are weights that are being applied to the two vectors, with values between 0 and 1. That is, if the user wanted to equally weight the prior and the sampling data, each weight would be given as 0.5. This function then multiplies each vector by its respective weight before adding the two vectors and plotting them. 

```{r}
library(Bayesian)


Posterior_Function<- function(Prior_Weight,prior,Sampling_Weight, FrequencyVector){
  Weighted_Prior <- Prior_Weight * prior
  Weighted_Sample <- Sampling_Weight * FrequencyVector
  Posterior_Data <- Weighted_Prior + Weighted_Sample
  Posterior <- dnorm(Posterior_Data, mean = mean(Posterior_Data), sd = sd(Posterior_Data))
  plot(prior_data, Posterior, type = "l", col = "green")
}
```
Below, is an example of the data which may be input into the Posterior_Function.

```{r, eval = FALSE}
library(Bayesian)
Prior_Weight <- .2
Sampling_Weight <- .8

Weighted_Prior <- vector(mode= "numeric", length = NumbTrials)
Weighted_Sample <- vector(mode= "numeric", length = NumbTrials)
Posterior_Data <- vector(mode= "numeric", length = NumbTrials)
Posterior <- vector(mode= "numeric", length = NumbTrials)

```


